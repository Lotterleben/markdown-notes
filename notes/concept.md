Title: Markdown Notes
Date: 2014-11-02
Tags: projects, markdown, lotte

# Idea

A system to write and organize notes written solely in (possibly extended) markdown. This should serve as a replacement for cloud-based tools such as Evernote or Google Keep.



## Outline

The tool should have at it's core a utility which does not do much more than organize the directory structure and possibly (git?) repository handling.

The directory structure managed by the utility would look something like this:

    •
    ├── notes.[which-config-file-format?]
    ├── notes/
    │   └── [contains all notes]
    └── [...] (stuff generated by plugins)

The `notes.[which-config-file-format?]` will be the main configuration file. No file format has been decided yet, but it should be simple and above all human readable.

The `notes/` folder would contain all notes managed by the utility


## The utility

The central utility/command-line tool would provide a couple of convenience functionality for managing them, such as (assuming that the command line app is called "`notes`"):

* Creating new notes
* Adding existing files to the notes repository
* Synchronizing your notes repository with a remote server.
    * There could be different synchronization providers, e.g. git-over-ssh, ftp or whatever. I guess we'd just start with a pure git-based thing?
    * Sync targets are configured in the config file.


### Possible set of commands

* `notes new [optional name]` creates a new file
* `notes sync [optional sync target]` would synchronize your repository with the configured remote.
* Incomplete!
* `notes add [path to file]` adds an already existing file to the repository.

### File handling

* Creating a new file: with current timestamp based on some template (TODO), e.g. "year-month-day-hour-minute-name". They are stored in `notes/` and an editor is opened for the newly created file.
* Adding an existing file: If it's a markdown file (TODO: How to detect?) it is categorized as a note and stored in `notes/`. If not, it is categorized as an asset and stored in `assets/` (see "Storing files"), and a dedicated note for that document is created, containing metadata and possibly notes for the file. Said note is opened in the editor.


## Plugins

The core utility would try to do as little as possible and all other functionality would be provided by plugins, which would be configured inside the main configuration file. There'd be different types of plugins:

* Directory organization: These could generate meaningful directory hierarchies from metadata in the notes. For example, a `date` plugin could create the following structure:

        •
        ├── 2014/
        │   └── 02/
        │       └── [notes from 02/2014]
        ├── 2013/
        │   └── ...
        └── ...

    And a `tags` plugin the following:

        •
        ├── foo/
        │   └── [all notes with tag foo]
        ├── bar/
        │   └── ...
        ├── baz/
        │   └── ...
        └── ...

    All the "notes" in these directories would be symlinks (what to do on Windowss?) to the main `notes/` directory as outlined above.

    As a second step, it might be possible to chain these to create a tag-based hierachy inside a date-based one and so on.

* Synchronization plugins: How to get your stuff onto the interwebs and back. Initially, this will be done through a plain git reposito



## Daemons

For some of the functionality it is desirable that it runs continously (such as syncing and hierarchy creation. For this, a daemon mode should be implemented. On OS X it could be started through launchd. TODO: Flesh out the details.



## Architecture

Assuming that we'll write this in Ruby we'd have two main components for the core utility:

1. The `notes` library. This would provide a convenient API for accessing notes and their content including their metadata and so on. This means that it'll have to do markdown parsing and some metadata processing. Also configuration file parsing.

2. The utility gem, which provides the command line utility as well as a plugin API for hierarchy generation, presentation and synchronization as explained above. It'd also incorporate the daemon functionality.



## Metadata format

We'd probably want to follow the syntax of MultiMarkdown here, as it seems to make sense and people(tm) have already implemented it in parsers and some utilities (e.g. Marked.app supports it). For example:

    Title: Awesome note
    Tags:  foo, bar, baz
    Date:  2014-02-13
    [newline]
    Actual markdown content

* https://pythonhosted.org/Markdown/extensions/meta_data.html
* http://hiltmon.com/blog/2012/06/18/markdown-metadata/
* https://github.com/fletcher/MultiMarkdown/wiki/MultiMarkdown-Syntax-Guide



## Storing files

In order to be really useful, it'd be desirable for this system to be able to store other filetypes as well, including images, PDF documents, etc.

These files would then be stored in a separate directory `assets/` next to notes. The original filename is _not_ preserved, but replaced by a SHA256 hash of the file (not the name, but it's contents). Apart from avoiding filename collision this has the benefit that it detects duplicate files.

For every file inside assets, there'd be a markdown file containing metadata for the file, e.g.

    Filename: foo.pdf
    Title: Awesome paper
    Authors: Foo et al.
    Published: 2014-04-13
    Hash: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
    Extension: pdf
    Mimetype: application/pdf
    Tags: foo, awesome, bar

    After the metadata block, notes for the file can be added.



## Frontend

In order to be really useful, proper visualization and searching of notes is required. These tasks would be performed by presentation front-ends. In the first step this could be a simple web-interface which allows searching notes through elastic search.

Architecturally, the interface between the frontend and the backend should happen via the `notes` command and not by reading files directly. By using the command as a facade, any properties of the actual notes repository could be changed without affecting frontend representation.



## Open questions / TODOs

### Backend

* How will this work on the mobiles and so on?
* How to link to other notes
* Better separate UX/UI ideas from implementation details


### Frontend

* Some/much of the organization functionality contained in Mendeley might be desirable?
