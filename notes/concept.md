Title: Markdown Notes
Date: 2014-11-02
Tags: projects, markdown, lotte

# Idea

A system to write and organize notes written solely in (possibly extended) markdown. This should serve as a replacement for cloud-based tools such as Evernote or Google Keep.



## Outline

The tool should have at it's core a utility which does not do much more than organize the directory structure and possibly (git?) repository handling.

The directory structure managed by the utility would look something like this:

    •
    ├── notes.[which-config-file-format?]
    ├── notes/
    │   └── [contains all notes]
    └── [...] (stuff generated by plugins)

The `notes.[which-config-file-format?]` will be the main configuration file. No file format has been decided yet, but it should be simple and above all human readable.

The `notes/` folder would contain all notes managed by the utility, which would provide a couple of convenience functionality for managing them, such as (assuming that the command line app is called "`notes`"):

* Creating new notes with `notes new [optional name]`, with a current timestamp based on some template (TODO). They are stored in `notes/` and an editor is opened for the newly created file.
* Adding existing files to the notes repository. If it's a markdown file (TODO: How to detect?) it is categorized as a note and stored in `notes/`. If not, it is categorized as an asset and stored in `assets/` (see "Storing files"), and a dedicated note for that document is created, containing metadata and possibly notes for the file. Said note is opened in the editor.
* Synchronizing your notes repository with a remote server using `notes sync [optional sync target]`.
    * There could be different synchronization providers, e.g. git-over-ssh, ftp or whatever. I guess we'd just start with a pure git-based thing?
    * Sync targets are configured in the config file.


## Plugins

The core utility would try to do as little as possible and all other functionality would be provided by plugins, which would be configured inside the main configuration file. There'd be different types of plugins:

* Directory organization: These could generate meaningful directory hierarchies from metadata in the notes. For example, a `date` plugin could create the following structure:

        •
        ├── 2014/
        │   └── 02/
        │       └── [notes from 02/2014]
        ├── 2013/
        │   └── ...
        └── ...

    And a `tags` plugin the following:

        •
        ├── foo/
        │   └── [all notes with tag foo]
        ├── bar/
        │   └── ...
        ├── baz/
        │   └── ...
        └── ...

    All the "notes" in these directories would be symlinks (what to do on Windowss?) to the main `notes/` directory as outlined above.

    As a second step, it might be possible to chain these to create a tag-based hierachy inside a date-based one and so on.

* Presentation plugins: In order to be really useful, proper visualization and searching of notes is required. These tasks would be performed by presentation plugins. In the first step this could be a simple web-interface which allows searching notes through elastic search.

* Synchronization plugins: How to get your stuff onto the interwebs and back. TODO: details.



## Daemons

For some of the functionality it is desirable that it runs continously (such as syncing and hierarchy creation. For this, a daemon mode should be implemented. On OS X it could be started through launchd. TODO: Flesh out the details.



## Architecture

Assuming that we'll write this in Ruby we'd have two main components for the core utility:

1. The `notes` library. This would provide a convenient API for accessing notes and their content including their metadata and so on. This means that it'll have to do markdown parsing and some metadata processing. Also configuration file parsing.

2. The utility gem, which provides the command line utility as well as a plugin API for hierarchy generation, presentation and synchronization as explained above. It'd also incorporate the daemon functionality.



## Metadata format

We'd probably want to follow the syntax of MultiMarkdown here, as it seems to make sense and people(tm) have already implemented it in parsers and some utilities (e.g. Marked.app supports it). For example:

    Title: Awesome note
    Tags:  foo, bar, baz
    Date:  2014-02-13
    [newline]
    Actual markdown content

* https://pythonhosted.org/Markdown/extensions/meta_data.html
* http://hiltmon.com/blog/2012/06/18/markdown-metadata/
* https://github.com/fletcher/MultiMarkdown/wiki/MultiMarkdown-Syntax-Guide



## Storing files

In order to be really useful, it'd be desirable for this system to be able to store other filetypes as well, including images, PDF documents, etc.

These files would then be stored in a separate directory `assets/` next to notes. The original filename is _not_ preserved, but replaced by a SHA256 hash of the file (not the name, but it's contents). Apart from avoiding filename collision this has the benefit that it detects duplicate files.

For every file inside assets, there'd be a markdown file containing metadata for the file, e.g.

    Filename: foo.pdf
    Title: Awesome paper
    Authors: Foo et al.
    Published: 2014-04-13
    Hash: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
    Extension: pdf
    Mimetype: application/pdf
    Tags: foo, awesome, bar

    After the metadata block, notes for the file can be added.

Adding a new file would be achieved through the `notes add [path to file]` as outlined above.

* Some/much of the organization functionality contained in Mendeley might be desirable?




## Open questions

* How will this work on the mobiles and so on?
* How to link to other notes
